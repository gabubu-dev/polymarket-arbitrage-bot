"""
FastAPI backend for Polymarket Arbitrage Bot UI.
Provides API endpoints for configuration, monitoring, and control.
"""

import os
import sys
import json
import asyncio
import subprocess
import sqlite3
from pathlib import Path
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta

from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel
import psutil

# Add bot source to path
BOT_ROOT = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(BOT_ROOT / "src"))

app = FastAPI(title="Polymarket Arbitrage Bot API", version="1.0.0")

# CORS - localhost and Tailscale
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000", 
        "http://127.0.0.1:3000",
        "http://100.89.126.70:3000",
        "http://fedora.tail747dab.ts.net:3000"
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Bot state
bot_process: Optional[subprocess.Popen] = None
bot_pid: Optional[int] = None

# File paths
CONFIG_PATH = BOT_ROOT / "config.json"
LOG_PATH = BOT_ROOT / "logs" / "bot.log"
TRADES_LOG_PATH = BOT_ROOT / "logs" / "trades.json"
# Point to the actual paper trading database in the Stable folder
PAPER_TRADING_DB = Path.home() / "Stable" / "polymarket-bot" / "paper_trading.db"


# ============================================================================
# Pydantic Models
# ============================================================================

class PolymarketConfig(BaseModel):
    api_key: str = ""
    api_secret: str = ""
    private_key: str = ""
    chain_id: int = 137


class ExchangeConfig(BaseModel):
    api_key: str = ""
    api_secret: str = ""
    testnet: bool = False


class TradingConfig(BaseModel):
    divergence_threshold: float = 0.05
    min_profit_threshold: float = 0.02
    position_size_usd: float = 100.0
    max_positions: int = 5
    max_position_size_usd: float = 500.0


class MarketsConfig(BaseModel):
    enabled_symbols: List[str] = ["BTC/USDT", "ETH/USDT"]
    polymarket_market_types: List[str] = ["15MIN_UP", "15MIN_DOWN"]
    refresh_interval_seconds: int = 5


class RiskManagementConfig(BaseModel):
    stop_loss_percentage: float = 0.15
    take_profit_percentage: float = 0.90
    max_daily_loss_usd: float = 1000.0
    emergency_shutdown_loss_usd: float = 5000.0


class LoggingConfig(BaseModel):
    level: str = "INFO"
    log_file: str = "logs/bot.log"
    log_trades: bool = True


class NotificationsConfig(BaseModel):
    enabled: bool = False
    webhook_url: str = ""


class BotConfig(BaseModel):
    polymarket: PolymarketConfig
    exchanges: Dict[str, ExchangeConfig]
    trading: TradingConfig
    markets: MarketsConfig
    risk_management: RiskManagementConfig
    logging: LoggingConfig
    notifications: NotificationsConfig


class BotStatus(BaseModel):
    running: bool
    pid: Optional[int]
    uptime_seconds: Optional[int]
    cpu_percent: Optional[float]
    memory_mb: Optional[float]


class Trade(BaseModel):
    timestamp: str
    symbol: str
    side: str
    size_usd: float
    entry_price: float
    exit_price: Optional[float]
    pnl: Optional[float]
    status: str


class PerformanceStats(BaseModel):
    daily_pnl: float
    weekly_pnl: float
    all_time_pnl: float
    total_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    open_positions: int


# ============================================================================
# Helper Functions
# ============================================================================

def mask_sensitive_value(value: str, show_chars: int = 4) -> str:
    """Mask sensitive string values, showing only last few characters."""
    if not value or len(value) <= show_chars:
        return "*" * 8
    return "*" * (len(value) - show_chars) + value[-show_chars:]


def unmask_if_unchanged(new_value: str, masked_value: str) -> Optional[str]:
    """Return None if value is masked (unchanged), otherwise return new value."""
    if new_value.startswith("*"):
        return None
    return new_value


def load_config() -> Dict[str, Any]:
    """Load configuration from JSON file."""
    if not CONFIG_PATH.exists():
        # Return default config
        return {
            "polymarket": {"api_key": "", "api_secret": "", "private_key": "", "chain_id": 137},
            "exchanges": {
                "binance": {"api_key": "", "api_secret": "", "testnet": False},
                "coinbase": {"api_key": "", "api_secret": ""}
            },
            "trading": {
                "divergence_threshold": 0.05,
                "min_profit_threshold": 0.02,
                "position_size_usd": 100.0,
                "max_positions": 5,
                "max_position_size_usd": 500.0
            },
            "markets": {
                "enabled_symbols": ["BTC/USDT", "ETH/USDT"],
                "polymarket_market_types": ["15MIN_UP", "15MIN_DOWN"],
                "refresh_interval_seconds": 5
            },
            "risk_management": {
                "stop_loss_percentage": 0.15,
                "take_profit_percentage": 0.90,
                "max_daily_loss_usd": 1000.0,
                "emergency_shutdown_loss_usd": 5000.0
            },
            "logging": {
                "level": "INFO",
                "log_file": "logs/bot.log",
                "log_trades": True
            },
            "notifications": {
                "enabled": False,
                "webhook_url": ""
            }
        }
    
    with open(CONFIG_PATH, 'r') as f:
        return json.load(f)


def save_config(config: Dict[str, Any]) -> None:
    """Save configuration to JSON file."""
    with open(CONFIG_PATH, 'w') as f:
        json.dump(config, f, indent=2)


def get_bot_status() -> BotStatus:
    """Get current bot status."""
    global bot_pid
    
    # Check if we have a stored PID
    if bot_pid:
        try:
            process = psutil.Process(bot_pid)
            if process.is_running() and 'python' in process.name().lower():
                # Calculate uptime
                create_time = process.create_time()
                uptime = int(datetime.now().timestamp() - create_time)
                
                return BotStatus(
                    running=True,
                    pid=bot_pid,
                    uptime_seconds=uptime,
                    cpu_percent=process.cpu_percent(interval=0.1),
                    memory_mb=process.memory_info().rss / 1024 / 1024
                )
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            bot_pid = None
    
    # Try to find bot process by searching for bot.py
    for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
        try:
            cmdline = proc.info['cmdline']
            if cmdline and 'bot.py' in ' '.join(cmdline):
                bot_pid = proc.info['pid']
                process = psutil.Process(bot_pid)
                create_time = process.create_time()
                uptime = int(datetime.now().timestamp() - create_time)
                
                return BotStatus(
                    running=True,
                    pid=bot_pid,
                    uptime_seconds=uptime,
                    cpu_percent=process.cpu_percent(interval=0.1),
                    memory_mb=process.memory_info().rss / 1024 / 1024
                )
        except (psutil.NoSuchProcess, psutil.AccessDenied, KeyError):
            continue
    
    return BotStatus(running=False, pid=None, uptime_seconds=None, cpu_percent=None, memory_mb=None)


def load_trades() -> List[Trade]:
    """Load trade history from logs."""
    if not TRADES_LOG_PATH.exists():
        return []
    
    trades = []
    try:
        with open(TRADES_LOG_PATH, 'r') as f:
            for line in f:
                try:
                    trade_data = json.loads(line.strip())
                    trades.append(Trade(**trade_data))
                except json.JSONDecodeError:
                    continue
    except Exception:
        return []
    
    return sorted(trades, key=lambda t: t.timestamp, reverse=True)


def calculate_performance() -> PerformanceStats:
    """Calculate performance statistics from trade history."""
    trades = load_trades()
    
    if not trades:
        return PerformanceStats(
            daily_pnl=0.0,
            weekly_pnl=0.0,
            all_time_pnl=0.0,
            total_trades=0,
            winning_trades=0,
            losing_trades=0,
            win_rate=0.0,
            open_positions=0
        )
    
    now = datetime.now()
    one_day_ago = now - timedelta(days=1)
    one_week_ago = now - timedelta(weeks=1)
    
    daily_pnl = 0.0
    weekly_pnl = 0.0
    all_time_pnl = 0.0
    winning_trades = 0
    losing_trades = 0
    open_positions = 0
    
    for trade in trades:
        trade_time = datetime.fromisoformat(trade.timestamp.replace('Z', '+00:00'))
        
        if trade.status == 'open':
            open_positions += 1
            continue
        
        pnl = trade.pnl or 0.0
        all_time_pnl += pnl
        
        if trade_time >= one_day_ago:
            daily_pnl += pnl
        
        if trade_time >= one_week_ago:
            weekly_pnl += pnl
        
        if pnl > 0:
            winning_trades += 1
        elif pnl < 0:
            losing_trades += 1
    
    total_closed = winning_trades + losing_trades
    win_rate = (winning_trades / total_closed * 100) if total_closed > 0 else 0.0
    
    return PerformanceStats(
        daily_pnl=daily_pnl,
        weekly_pnl=weekly_pnl,
        all_time_pnl=all_time_pnl,
        total_trades=len(trades),
        winning_trades=winning_trades,
        losing_trades=losing_trades,
        win_rate=win_rate,
        open_positions=open_positions
    )


def get_recent_logs(num_lines: int = 100) -> List[str]:
    """Get recent log lines."""
    if not LOG_PATH.exists():
        return []
    
    try:
        with open(LOG_PATH, 'r') as f:
            lines = f.readlines()
            return [line.strip() for line in lines[-num_lines:]]
    except Exception:
        return []


# ============================================================================
# API Endpoints
# ============================================================================

@app.get("/")
async def root():
    """Root endpoint."""
    return {"message": "Polymarket Arbitrage Bot API", "version": "1.0.0"}


@app.get("/api/config")
async def get_config():
    """Get current configuration with masked sensitive values."""
    config = load_config()
    
    # Mask sensitive values
    if config.get('polymarket'):
        config['polymarket']['api_key'] = mask_sensitive_value(config['polymarket'].get('api_key', ''))
        config['polymarket']['api_secret'] = mask_sensitive_value(config['polymarket'].get('api_secret', ''))
        config['polymarket']['private_key'] = mask_sensitive_value(config['polymarket'].get('private_key', ''))
    
    for exchange_name in config.get('exchanges', {}):
        config['exchanges'][exchange_name]['api_key'] = mask_sensitive_value(
            config['exchanges'][exchange_name].get('api_key', '')
        )
        config['exchanges'][exchange_name]['api_secret'] = mask_sensitive_value(
            config['exchanges'][exchange_name].get('api_secret', '')
        )
    
    if config.get('notifications', {}).get('webhook_url'):
        config['notifications']['webhook_url'] = mask_sensitive_value(
            config['notifications']['webhook_url']
        )
    
    return config


@app.post("/api/config")
async def update_config(new_config: BotConfig):
    """Update configuration. Masked values (starting with *) are not updated."""
    current_config = load_config()
    new_config_dict = new_config.model_dump()
    
    # Handle polymarket config
    if new_config_dict.get('polymarket'):
        for key in ['api_key', 'api_secret', 'private_key']:
            new_val = new_config_dict['polymarket'].get(key, '')
            if not new_val.startswith('*'):
                current_config.setdefault('polymarket', {})[key] = new_val
        
        current_config['polymarket']['chain_id'] = new_config_dict['polymarket'].get('chain_id', 137)
    
    # Handle exchanges
    for exchange_name, exchange_data in new_config_dict.get('exchanges', {}).items():
        if exchange_name not in current_config.setdefault('exchanges', {}):
            current_config['exchanges'][exchange_name] = {}
        
        for key in ['api_key', 'api_secret']:
            new_val = exchange_data.get(key, '')
            if not new_val.startswith('*'):
                current_config['exchanges'][exchange_name][key] = new_val
        
        current_config['exchanges'][exchange_name]['testnet'] = exchange_data.get('testnet', False)
    
    # Update non-sensitive configs directly
    current_config['trading'] = new_config_dict.get('trading', current_config.get('trading', {}))
    current_config['markets'] = new_config_dict.get('markets', current_config.get('markets', {}))
    current_config['risk_management'] = new_config_dict.get('risk_management', current_config.get('risk_management', {}))
    current_config['logging'] = new_config_dict.get('logging', current_config.get('logging', {}))
    
    # Handle notifications webhook URL
    if new_config_dict.get('notifications'):
        webhook_url = new_config_dict['notifications'].get('webhook_url', '')
        if not webhook_url.startswith('*'):
            current_config.setdefault('notifications', {})['webhook_url'] = webhook_url
        current_config['notifications']['enabled'] = new_config_dict['notifications'].get('enabled', False)
    
    # Save updated config
    save_config(current_config)
    
    return {"message": "Configuration updated successfully"}


@app.get("/api/status")
async def get_status():
    """Get bot status and performance metrics."""
    bot_status = get_bot_status()
    performance = calculate_performance()
    
    return {
        "bot": bot_status.model_dump(),
        "performance": performance.model_dump()
    }


@app.get("/api/trades")
async def get_trades(limit: int = 50):
    """Get recent trades."""
    trades = load_trades()
    return [trade.model_dump() for trade in trades[:limit]]


@app.post("/api/control/start")
async def start_bot(background_tasks: BackgroundTasks):
    """Start the bot."""
    global bot_process, bot_pid
    
    status = get_bot_status()
    if status.running:
        raise HTTPException(status_code=400, detail="Bot is already running")
    
    # Verify config exists
    if not CONFIG_PATH.exists():
        raise HTTPException(status_code=400, detail="Configuration file not found. Please configure the bot first.")
    
    # Start bot process
    try:
        bot_script = BOT_ROOT / "bot.py"
        bot_process = subprocess.Popen(
            [sys.executable, str(bot_script)],
            cwd=str(BOT_ROOT),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            start_new_session=True
        )
        bot_pid = bot_process.pid
        
        # Give it a moment to start
        await asyncio.sleep(1)
        
        return {"message": "Bot started successfully", "pid": bot_pid}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to start bot: {str(e)}")


@app.post("/api/control/stop")
async def stop_bot():
    """Stop the bot."""
    global bot_pid
    
    status = get_bot_status()
    if not status.running:
        raise HTTPException(status_code=400, detail="Bot is not running")
    
    try:
        process = psutil.Process(status.pid)
        process.terminate()
        
        # Wait for graceful shutdown
        try:
            process.wait(timeout=10)
        except psutil.TimeoutExpired:
            process.kill()
        
        bot_pid = None
        return {"message": "Bot stopped successfully"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to stop bot: {str(e)}")


@app.post("/api/control/restart")
async def restart_bot(background_tasks: BackgroundTasks):
    """Restart the bot."""
    # Stop if running
    status = get_bot_status()
    if status.running:
        await stop_bot()
        await asyncio.sleep(2)
    
    # Start
    return await start_bot(background_tasks)


@app.get("/api/logs")
async def get_logs(lines: int = 100):
    """Get recent log lines."""
    logs = get_recent_logs(lines)
    return {"logs": logs}


@app.delete("/api/logs")
async def clear_logs():
    """Clear log files."""
    try:
        if LOG_PATH.exists():
            LOG_PATH.unlink()
        if TRADES_LOG_PATH.exists():
            TRADES_LOG_PATH.unlink()
        
        # Recreate logs directory
        LOG_PATH.parent.mkdir(exist_ok=True)
        
        return {"message": "Logs cleared successfully"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to clear logs: {str(e)}")


@app.get("/api/positions")
async def get_positions():
    """Get all open positions from paper trading database."""
    if not PAPER_TRADING_DB.exists():
        return {"positions": [], "message": "Database not found"}
    
    try:
        conn = sqlite3.connect(str(PAPER_TRADING_DB))
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT market_id, outcome, entry_price, shares, side, opened_at, trade_id
            FROM positions
            ORDER BY opened_at DESC
        """)
        
        rows = cursor.fetchall()
        positions = [dict(row) for row in rows]
        conn.close()
        
        return {"positions": positions, "count": len(positions)}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@app.get("/api/paper-stats")
async def get_paper_stats():
    """Get paper trading statistics: balance, P&L, trade count, win rate."""
    if not PAPER_TRADING_DB.exists():
        return {
            "balance": 1000.0,
            "total_pnl": 0.0,
            "total_trades": 0,
            "winning_trades": 0,
            "losing_trades": 0,
            "win_rate": 0.0,
            "open_positions": 0,
            "total_equity": 1000.0
        }
    
    try:
        conn = sqlite3.connect(str(PAPER_TRADING_DB))
        cursor = conn.cursor()
        
        # Get current balance
        cursor.execute("SELECT value FROM state WHERE key='balance'")
        balance_row = cursor.fetchone()
        balance = float(balance_row[0]) if balance_row else 1000.0
        
        # Get trade statistics
        cursor.execute("""
            SELECT 
                COUNT(*) as total_trades,
                COALESCE(SUM(CASE WHEN realized_pnl > 0 THEN 1 ELSE 0 END), 0) as winning_trades,
                COALESCE(SUM(CASE WHEN realized_pnl < 0 THEN 1 ELSE 0 END), 0) as losing_trades,
                COALESCE(SUM(realized_pnl), 0) as total_pnl
            FROM trades
            WHERE realized_pnl IS NOT NULL
        """)
        
        trade_stats = cursor.fetchone()
        total_trades, winning_trades, losing_trades, total_pnl = trade_stats
        
        # Get open positions count
        cursor.execute("SELECT COUNT(*) FROM positions")
        open_positions = cursor.fetchone()[0]
        
        # Get total positions value
        cursor.execute("""
            SELECT COALESCE(SUM(shares * entry_price), 0) as positions_value
            FROM positions
        """)
        positions_value = cursor.fetchone()[0]
        
        conn.close()
        
        win_rate = (winning_trades / total_trades * 100) if total_trades > 0 else 0.0
        total_equity = balance + positions_value
        
        return {
            "balance": round(balance, 2),
            "total_pnl": round(total_pnl or 0.0, 2),
            "total_trades": total_trades or 0,
            "winning_trades": winning_trades or 0,
            "losing_trades": losing_trades or 0,
            "win_rate": round(win_rate, 2),
            "open_positions": open_positions or 0,
            "total_equity": round(total_equity, 2),
            "positions_value": round(positions_value, 2)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@app.get("/api/paper-trades")
async def get_paper_trades(limit: int = 50):
    """Get recent paper trades from database."""
    if not PAPER_TRADING_DB.exists():
        return {"trades": [], "count": 0}
    
    try:
        conn = sqlite3.connect(str(PAPER_TRADING_DB))
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT id, timestamp, market_id, outcome, side, shares, price, 
                   amount, fees, slippage, total_cost, realized_pnl, realized_pnl_percent
            FROM trades
            ORDER BY timestamp DESC
            LIMIT ?
        """, (limit,))
        
        rows = cursor.fetchall()
        trades = [dict(row) for row in rows]
        conn.close()
        
        return {"trades": trades, "count": len(trades)}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@app.get("/api/balance")
async def get_balance():
    """Get current balance and equity from paper trading."""
    if not PAPER_TRADING_DB.exists():
        return {"balance": 1000.0, "equity": 1000.0, "positions_value": 0.0}
    
    try:
        conn = sqlite3.connect(str(PAPER_TRADING_DB))
        cursor = conn.cursor()
        
        # Get current balance
        cursor.execute("SELECT value FROM state WHERE key='balance'")
        balance_row = cursor.fetchone()
        balance = float(balance_row[0]) if balance_row else 1000.0
        
        # Get total positions value
        cursor.execute("""
            SELECT COALESCE(SUM(shares * entry_price), 0) as positions_value
            FROM positions
        """)
        positions_value = cursor.fetchone()[0]
        
        # Get latest balance history entry
        cursor.execute("""
            SELECT balance, total_positions_value, total_equity
            FROM balance_history
            ORDER BY timestamp DESC
            LIMIT 1
        """)
        
        history_row = cursor.fetchone()
        if history_row:
            equity = history_row[2]
        else:
            equity = balance + positions_value
        
        conn.close()
        
        return {
            "balance": round(balance, 2),
            "equity": round(equity, 2),
            "positions_value": round(positions_value, 2)
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Database error: {str(e)}")


@app.get("/api/health")
async def health_check():
    """Health check endpoint."""
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}


if __name__ == "__main__":
    import uvicorn
    
    # Ensure logs directory exists
    LOG_PATH.parent.mkdir(parents=True, exist_ok=True)
    
    # Run on all interfaces for Tailscale access
    uvicorn.run(
        app,
        host="0.0.0.0",
        port=8000,
        log_level="info"
    )
